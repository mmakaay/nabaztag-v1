include core/constants

# (See also doc/ears.md)
# The ears are moved by two motors.
#
# Each motor has a related encoder unit, which is used to know the position
# of the ears. This encoder is a 20 teeth wheel, which misses 3 of its teeth.
#
# To sync an ear, I turn on its motor, while keeping a tab on the motor
# encoder values. As long as an encoder value does not change, a counter
# is incremented. As soon as the value does change, the counter value is used
# # as a measure for the amount of time that has passed between two encoder
# wheel teeth.
#
# When the encoder has passed the 3 teeth gap, the counter will be higher
# than a counter for a regular gap. Therefore, this counter can be used
# to identify the start position of the motor.
#
# Based on experimentation, I found that threshold values from 7 to 25
# yield good results for recognizing the 3 teeth encoder gap.
#
# Below 7, the gap was sometimes falsely detected too soon. Above 25,
# the gap was not detected at all. Thresholds close to these boundaries
# produced unpredictable results.
#
# This is good! There is a wide range of thresholds that do work. To let
# the sync work as quick as possible, I chose a value on the low side.
# If other people's bunnies have troubles with this (resulting in failing
# sync, stopping the ear before the sync point) the value might have to
# be adjusted to a higher value.
#
# Note that these measurements do depend on the code that is used for
# syncing. When the code is changed, new measurements might be required.
# It might be a good idea to switch to a real time-based gap detection,
# since that would be less dependent on the exact code structure. For
# now, this method seems just fine.

define $left         R0
define $l_new        R1
define $l_old        R2
define $l_gap_size   R3
define $right        R4
define $r_new        R5
define $r_old        R6
define $r_gap_size   R7
define $direction    R8
define $threshold    R9
define $too_much     R10
define $sync_state   R11
define $sync_check   R12

@Ears.Sync()
    PUSH 0xff, 0xff               # Allows me to fiddle with all registers

    LD $threshold, 9              # Gap detection threshold, see above
    LD $too_much, 50              # If counter exceeds this, ear might be stuck
    LD $sync_state 0x11           # To keep track if both ears are synced
    LD $left,%MOTOR_LEFT          # Left motor number
    LD $right, %MOTOR_RIGHT       # Right motor number

    LD $direction, %REVERSE       # First, start both motors in reverse for a
    MOTOR $left, $direction       # little while. When the ears were synced
    MOTOR $right, $direction      # before, this will bring them right in front
    WAIT 30                       # of the gap, making the sync operation fast

    LD $direction, %FORWARD       # Now start both motors to make the ears
    MOTOR $left, $direction       # turn in the forward direction
    MOTOR $right, $direction

    MOTORGET $l_new, $left        # Get the encoder value for the left motor
    LD $l_old, $l_new             # Copy the value to the old value register
    CLR $l_gap_size               # Clear the gap size counter

    MOTORGET $r_new, $right       # Do the same for the right ear
    LD $r_old, $r_new
    CLR $r_gap_size

@sync_loop
    WAIT 1                        # required to update the motor encoders

@sync_left
    LD $sync_check, $sync_state   # Check if syncing has already been completed
    AND $sync_check, 0x10
    TST $sync_check
    BEQ @sync_right

    MOTORGET $l_new, $left        # Get new left motor encoder value
    CMP $l_old, $l_new            # Compare to the known value
    BNE @check_for_gap_left       # If it changed, check if we're at the gap
    INC $l_gap_size               # If not, then increment the gap size counter

    CMP $l_gap_size, $too_much    # Compare to the 'too much' threshold
    BGE @stop_sync_left           # Stop syncing ear if it seems stuck

@sync_right
    LD $sync_check, $sync_state   # Do the same for the right motor.
    AND $sync_check, 0x01
    TST $sync_check
    BEQ @restart_if_not_yet_synced

    MOTORGET $r_new, $right
    CMP $r_old, $r_new
    BNE @check_for_gap_right
    INC $r_gap_size

    CMP $r_gap_size, $too_much
    BGE @stop_sync_right

@restart_if_not_yet_synced
    TST $sync_state               # If there are still sync bits active
    BNE @sync_loop                # then restart the sync loop
    BRA @done

@check_for_gap_left
    LD $l_old, $l_new             # Keep track of the new encoder value
    CMP $l_gap_size, $threshold   # If the gap size exceeds the threshold
    BGT @stop_sync_left           # then we found the gap, the ear is in sync!
    CLR $l_gap_size               # Otherwise this was a normal tick, clear it
    BRA @sync_right               # and continue with the sync process

@stop_sync_left
    LD $direction, %STOP          # Stop the left motor
    MOTOR $left, $direction
    AND $sync_state, 0x01         # Flag this one as synced
    BRA @sync_right               # and continue with the sync process

@check_for_gap_right
    LD $r_old, $r_new             # Do the same for the right ear
    CMP $r_gap_size, $threshold
    BGT @stop_sync_right
    CLR $r_gap_size
    BRA @sync_loop

@stop_sync_right
    LD $direction, %STOP
    MOTOR $right, $direction
    AND $sync_state, 0x10
    BRA @restart_if_not_yet_synced

@done
    # Store the ear state data in the RAM.
    LD $direction, 0
    STR $l_old, *LEFT_EAR_START
    STR $l_old, *LEFT_EAR_TARGET
    STR $direction, *LEFT_EAR_DIRECTION
    STR $r_old, *RIGHT_EAR_START
    STR $r_old, *RIGHT_EAR_TARGET
    STR $direction, *RIGHT_EAR_DIRECTION

    PULL 0xff, 0xff               # Restore all registers
    RTS                           # Return to the caller
