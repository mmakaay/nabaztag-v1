include motors
include ram

# Both ear motors have a related encoder unit, which can be used to
# determine the position of the ears. This encoder is a 20 teeth wheel,
# which misses 3 of its teeth. An IR sensor looks at the wheel, and
# every time a tooth is in front of the sensor, the encoder value is
# incremented. One rotation of the ears will result in one rotation
# of the wheel as well. The 3 teeth gap is used to identify the home
# position of the ears.
# 
# Here's a schema of the way in which the encoder wheels are laid out:
#
#               |
#       \   04 03 02   /<.
#        05          01    `  encoder gap
#      06              ..    ` 
#     07                ..    |
#  -- 08                .. -- +
#     09                17
#      10              16
#        11          15
#       /   12 13 14   \
#               |
#
# In the ear syncing code, I let the ears rotate, while keeping a tab on
# the motor encoder values. As long as an encoder value does not change,
# a counter for the respective motor is incremented. As soon as the value
# does change, the counter acts a measure for the amount of time that has
# passed between two of the encoder wheel teeth.
#
# When the encoder has passed the 3 teeth gap, the counter will be higher
# than the counters between two regular teeth. Therefore, the counter can
# be used to identify the starting position.
#
# Based on experimentation, I found that threshold values from 7 to 25
# yield good results for syncing up the ear motors with the encoder gap.
# 
# Below 7, the gap was sometimes falsely detected too soon. Above 25,
# the gap was not detected at all. Thresholds close to these boundaries
# produced unpredictable results.
#
# This is good! There is a wide range of thresholds that do work. To let
# the sync work as quick as possible, I chose a value on the low side.
# If other people's bunnies have troubles with this (resulting in failing
# sync, stopping the ear before the sync point) the value might have to
# be adjusted to a higher value.
#
# Note that these measurements highly depend on the exact code that is
# used for syncing. WHen the code changes, I'll have to do new measurements.
# It might be a good idea to start using time-based gap detection, since
# that might be less dependent on the exact code structure.

@SyncEars()
    define $left         R0
    define $l_new        R1
    define $l_old        R2
    define $l_gap_size   R3
    define $right        R4
    define $r_new        R5
    define $r_old        R6
    define $r_gap_size   R7
    define $threshold    R8
    define $sync_state   R9

    PUSH 0xff, 0xff               # Allows me to fiddle with all registers

    LD $threshold, 9              # Gap detection threshold, see above
    LD $sync_state 0x11           # To keep track if both ears are synced
    LD $left %MOTOR_LEFT          # Left motor number
    LD $right %MOTOR_RIGHT        # Right motor number

    BSR @ReverseLeftMotor()       # First, start both motors to make the ears
    BSR @ReverseRightMotor()      # turn in reverse direction. When they were
    WAIT 30                       # up and synced before, this speeds up syncing

    BSR @ForwardLeftMotor()       # Now start both motors to make the ears
    BSR @ForwardRightMotor()      # turn in the forward direction

    MOTORGET $l_new, $left        # Get the encoder value for the left motor
    LD $l_old, $l_new             # Copy the value to the old value register
    CLR $l_gap_size               # Clear the gap size counter

    MOTORGET $r_new, $right       # Do the same for the right ear
    LD $r_old, $r_new
    CLR $r_gap_size

@sync_loop
    WAIT 1                        # required to update the motor encoders

@sync_left
    MOTORGET $l_new, $left        # Get new left motor encoder value
    CMP $l_old, $l_new            # Compare to the known value
    BNE @check_for_gap_left       # If it changed, check if we're at the gap
    INC $l_gap_size               # If not, then increment the gap size counter

@sync_right
    MOTORGET $r_new, $right       # Do the same for the right motor
    CMP $r_old, $r_new
    BNE @check_for_gap_right
    INC $r_gap_size

@restart_if_not_yet_synced
    TST $sync_state               # If there are still sync bits active
    BNE @sync_loop                # then restart the sync loop

@done
    STR $l_old, *LEFT_EAR_START   # Otherwise, store the motor start positions
    STR $r_old, *RIGHT_EAR_START  # of the two ears in RAM memory
    PULL 0xff, 0xff               # Restore all registers
    RTS                           # Return to the caller

@check_for_gap_left
    LD $l_old, $l_new             # Keep track of the new encoder value
    CMP $l_gap_size, $threshold   # If the gap size exceeds the threshold
    BGT @gap_l_found              # then we found the gap, the ear is in sync!
    CLR $l_gap_size               # Otherwise this was a normal tick, clear it
    BRA @sync_right               # and continue with the sync process

@gap_l_found
    BSR @StopLeftMotor()          # Stop the motor now the ear is in sync
    AND $sync_state, 0x01         # Flag this one as synced
    BRA @sync_right               # and continue with the sync process

@check_for_gap_right
    LD $r_old, $r_new             # Do the same for the right ear
    CMP $r_gap_size, $threshold
    BGT @gap_right_found
    CLR $r_gap_size
    BRA @sync_loop

@gap_right_found
    BSR @StopRightMotor()
    AND $sync_state, 0x10
    BRA @restart_if_not_yet_synced

